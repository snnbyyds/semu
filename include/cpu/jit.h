/*
 * Copyright 2025 Nuo Shen, Nanjing University
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __JIT_H__
#define __JIT_H__

#include <cpu/inst.h>
#include <cpu/fpu.h>
#include <utils/state.h>
#include <string.h>

typedef struct {
    char *c_code;
    size_t len;
} code_block_t;

#define CODE_BLOCK_INITIALIZER {NULL, 0}

#define SEMU_APIS(_) \
    _(f32_add) _(f32_sub) _(f32_mul) \
    _(f32_mulAdd) _(f32_div) _(f32_rem) _(f32_sqrt) \
    _(f32_eq) _(f32_le) _(f32_lt) _(f32_le_quiet) \
    _(f32_lt_quiet) _(f32_isSignalingNaN) _(f32_to_ui32) _(f32_to_i32) \
    _(f32_to_f64) _(f64_to_ui32) _(f64_to_i32) _(f64_to_f32) \
    _(f64_add) _(f64_sub) _(f64_mul) _(f64_mulAdd) \
    _(f64_div) _(f64_rem) _(f64_sqrt) _(f64_eq) \
    _(f64_le) _(f64_lt) _(f64_le_quiet) _(f64_lt_quiet) \
    _(f64_isSignalingNaN) _(ui32_to_f64) _(ui32_to_f32) _(i32_to_f32) \
    _(i32_to_f64) \
    _(classify_s) _(is_nan) _(classify_d) _(is_nan64) \
    _(set_rounding_mode) _(set_fflag) _(unboxF32) _(set_fpr_nan_box_upper_bits) \
    _(vaddr_read_d) _(vaddr_read_w) _(vaddr_read_s) _(vaddr_read_b) \
    _(vaddr_write_d) _(vaddr_write_w) _(vaddr_write_s) _(vaddr_write_b)

/* Wrap semu api here for code generated by JIT */
typedef struct {
    /* Float point operations */
    float32_t(*f32_add)(float32_t, float32_t);
    float32_t(*f32_sub)(float32_t, float32_t);
    float32_t(*f32_mul)(float32_t, float32_t);
    float32_t(*f32_mulAdd)(float32_t, float32_t, float32_t);
    float32_t(*f32_div)(float32_t, float32_t);
    float32_t(*f32_rem)(float32_t, float32_t);
    float32_t(*f32_sqrt)(float32_t);
    bool(*f32_eq)(float32_t, float32_t);
    bool(*f32_le)(float32_t, float32_t);
    bool(*f32_lt)(float32_t, float32_t);
    bool(*f32_le_quiet)(float32_t, float32_t);
    bool(*f32_lt_quiet)(float32_t, float32_t);
    bool(*f32_isSignalingNaN)(float32_t);
    uint_fast32_t(*f32_to_ui32)(float32_t, uint_fast8_t, bool);
    int_fast32_t(*f32_to_i32)(float32_t, uint_fast8_t, bool);
    float64_t(*f32_to_f64)(float32_t);
    uint_fast32_t(*f64_to_ui32)(float64_t, uint_fast8_t, bool);
    int_fast32_t(*f64_to_i32)(float64_t, uint_fast8_t, bool);
    float32_t(*f64_to_f32)(float64_t);
    float64_t(*f64_add)(float64_t, float64_t);
    float64_t(*f64_sub)(float64_t, float64_t);
    float64_t(*f64_mul)(float64_t, float64_t);
    float64_t(*f64_mulAdd)(float64_t, float64_t, float64_t);
    float64_t(*f64_div)(float64_t, float64_t);
    float64_t(*f64_rem)(float64_t, float64_t);
    float64_t(*f64_sqrt)(float64_t);
    bool(*f64_eq)(float64_t, float64_t);
    bool(*f64_le)(float64_t, float64_t);
    bool(*f64_lt)(float64_t, float64_t);
    bool(*f64_le_quiet)(float64_t, float64_t);
    bool(*f64_lt_quiet)(float64_t, float64_t);
    bool(*f64_isSignalingNaN)(float64_t);
    float64_t(*ui32_to_f64)(uint32_t);
    float32_t(*ui32_to_f32)(uint32_t);
    float32_t(*i32_to_f32)(int32_t);
    float64_t(*i32_to_f64)(int32_t);
    uint32_t (*classify_s)(uint32_t);
    bool (*is_nan)(uint32_t);
    uint32_t (*classify_d)(uint64_t);
    bool (*is_nan64)(uint64_t);
    void (*set_rounding_mode)(uint32_t);
    void (*set_fflag)();
    float32_t (*unboxF32)(fpr_t);
    void (*set_fpr_nan_box_upper_bits)(int);

    /* Memory */
    uint64_t (*vaddr_read_d)(vaddr_t);
    uint32_t (*vaddr_read_w)(vaddr_t);
    uint16_t (*vaddr_read_s)(vaddr_t);
    uint8_t (*vaddr_read_b)(vaddr_t);
    void (*vaddr_write_d)(vaddr_t, uint64_t);
    void (*vaddr_write_w)(vaddr_t, uint32_t);
    void (*vaddr_write_s)(vaddr_t, uint16_t);
    void (*vaddr_write_b)(vaddr_t, uint8_t);
} semu_api_t;

/* API Wrapper */
extern semu_api_t shared_api;

#define CACHE_ENTRY_SIZE (64 * 1024)
#define CACHE_SIZE       (64 * 1024 * 1024)
#define CACHE_HOT        65536

typedef struct {
    vaddr_t pc;
    uint64_t hot;
    size_t offset;
} cache_item_t;

typedef struct {
    uint8_t *jitcode;
    size_t offset;
    cache_item_t table[CACHE_ENTRY_SIZE];
} cache_t;

typedef void (*block_exec_t)(EMU_State *restrict, exec_t *restrict);

cache_t *jitcache_new();
uint8_t *jitcache_find(cache_t *cache, vaddr_t pc);
uint8_t *jitcache_add(cache_t *cache, vaddr_t pc, const void *code, size_t size, uint64_t align);
bool jitcache_hot(cache_t *cache, vaddr_t pc);

void jit_set_fallback_interpreter(block_exec_t interpreter);
code_block_t *jit_gen_c_code(vaddr_t start_pc);
uint8_t *jit_compiler(code_block_t *code, cache_t *cache);

#endif
